################################################################
# $HOME/.zshrc.local of Bernhard Tittelbach
################################################################
# This file is based on grml's .zshrc.local and intended for use
# alongside grml's zshrc. I made some additions that help with my
# workflow as well as copied stuff from other people. Feel free to
# copy and modify anything from this config.
#
# you can get the lastest version of this and associated files
# from https://www.tittelbach.at/zsh/ or by calling UpdateMyZshrc
# (which will prompt you before updating anything)
################################################################


### ZLE tweaks  ########################

## set command prediction from history, see 'man 1 zshcontrib'
#is4 && zrcautoload predict-on && \
#zle -N predict-on         && \
#zle -N predict-off        && \
#bindkey "^x^Z" predict-on && \
#bindkey "^Z" predict-off

# load our function and completion directories
for fdir in ${ZSH_USER_FUNCTIONS_DIR:-~/.zsh/functions}; do
    fpath+=( ${fdir} ${fdir}/**/*(/N) )
      for func in ${fdir}/**/[^_]*[^~](N.) ; do
          zrcautoload ${func:t}
      done
done
unset fdir func

### Key-Un-Bindings (do this first, in case we want to reassign some later) ########################

#unbind Strg-O from "enter"
bindkey -r "^o"


### remove unneded Functions (free some memory) ########################
## still needed as they may be in /etc/zsh/zshrc on some systems
for ufc (asc brltty swspeak audiorip audioburn mkaudiocd mkiso H-Glob cdrecord smartcompress) unfunction $ufc &>/dev/null

### Add Directories to Path if they are not already there ########################

#$path is a zsh array which mirrors $PATH. $path is typeset -U so it's entries are always unique
path+=(/sbin /usr/sbin /usr/local/bin /usr/local/sbin)


### Autogenerate some more completions

compdef _gnu_generic unison unison-gtk hddtemp tee free exiftran dd_rescue zenity htags Xorg mkfs.vfat mkfs.ntfs mkfs.ext3 mkfs.ext4 mkfs.btrfs fsck.vfat fsck.ext4 fsck.ext3 fsck.ext2 fsck.btrfs grml2usb inxi
compdef _gcc gpp g++ cc c++

### My directory hashes ########################

[[ -e ~/.zshrc.dirhash ]] && . ~/.zshrc.dirhash


### Shell Options ########################

setopt AUTO_CD GLOB_COMPLETE EXTENDED_GLOB GLOB HIST_SUBST_PATTERN HIST_EXPIRE_DUPS_FIRST HIST_FIND_NO_DUPS HIST_IGNORE_SPACE HIST_REDUCE_BLANKS HIST_VERIFY SHARE_HISTORY ALIASES CORRECT AUTO_CONTINUE HIST_NO_STORE MULTIOS

## remove pattern from list if no matches instead of reporting error or substituting pattern
#setopt NULL_GLOB
## remove pattern from list if no matches but report error if not matches left
setopt CSH_NULL_GLOB

## warning if file exists ('cat /dev/null > ~/.zshrc').
## to ignore warning, just use last history entry
setopt NO_CLOBBER HIST_ALLOW_CLOBBER

## any word=  argument on the CL gets magic file completion
setopt MAGIC_EQUAL_SUBST

## don't warn me about bg processes when exiting
#setopt nocheckjobs

## alert me if something failed
#setopt printexitvalue

## with spelling correction, assume dvorak kb
#setopt dvorak

## Allow comments even in interactive shells
#setopt interactivecomments

## Brace {a-z} Character Expansion
setopt BRACE_CCL

export HISTSIZE=1000000
export SAVEHIST=100000
export HISTFILE=$HOME/.zsh_history

## define word separators (for stuff like backward-word, forward-word, backward-kill-word,..)
WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>' # the default
#WORDCHARS=.
#WORDCHARS='*?_[]~=&;!#$%^(){}'
#WORDCHARS='${WORDCHARS:s@/@}'

## define help-page length
HELP_LINES_PER_PAGE=22

### compsys related snippets, from grml and Sven Guckes ########################

## changed completer settings
#zstyle ':completion:*' completer _complete _correct _approximate
#zstyle ':completion:*' expand prefix suffix

## another different completer setting: expand shell aliases
#zstyle ':completion:*' completer _expand_alias _complete _approximate

## to have more convenient account completion, specify your logins:
#my_accounts=(
# {grml,grml1}@foo.invalid
# grml-devel@bar.invalid
#)
#other_accounts=(
# {fred,root}@foo.invalid
# vera@bar.invalid
#)
#zstyle ':completion:*:my-accounts' users-hosts $my_accounts
#zstyle ':completion:*:other-accounts' users-hosts $other_accounts

## the default grml setup provides '..' as a completion. it does not provide
## '.' though. If you want that too, use the following line:
#zstyle ':completion:*' special-dirs true

## don't list temporary-, backup- or compiler-files in file-completion, except when deleting something
zstyle ':completion:*:*:(^(rm|gvfs-rm|trash|gvfs-trash|wipe)):*:(all-|)files' ignored-patterns "*~" "*.(BAK|bak|o|aux|nav|snm|out|tex.backup|bbl|blg|bib.backup|vrb|lof|lot|hd|idx|swp|pyc|hi)"

## menu-complete not starting with 5 but 3 choices
zstyle ':completion:*'   menu select=3

## configure VCS_INFO to detect git after svn (because git controlled homedir would overshadow svn subdirs)
zstyle ":vcs_info:-init-:default:-all-" enable svn hg bzr darcs git p4 cvs cdv mtn svk tla

### Miscellaneous Stuff from grml ########################

## Use a default width of 80 for manpages for more convenient reading
#export MANWIDTH=${MANWIDTH:-80}

## Set a search path for the cd builtin
#cdpath=(.. ~)

## variation of our manzsh() function; pick you poison:
#manzsh()  { /usr/bin/man zshall |  most +/"$1" ; }

## Switching shell safely and efficiently? http://www.zsh.org/mla/workers/2001/msg02410.html
#bash() {
#    NO_SWITCH="yes" command bash "$@"
#}
#restart () {
#    exec $SHELL $SHELL_ARGS "$@"
#}

## log out? set timeout in seconds...
## ...and do not log out in some specific terminals:
#if [[ "${TERM}" == ([Exa]term*|rxvt|dtterm|screen*) ]] ; then
#    unset TMOUT
#else
#    TMOUT=1800
#fi


### define some handy ZLE functions and bind them to a key ########################

## press ctrl-Oq to quote everything after the first word:
function mquote()
{
      zle beginning-of-line
      zle forward-word
      zle set-mark-command
      zle end-of-line
      zle quote-region
}
#k# quote everything after the first word
zle -N mquote && bindkey '^oq' mquote

## press ctrl-O_ to replace spaces with underscores in either
## * the current selection (if something is selected)
## * the current word (if the current word contains spaces)
## * or everything from the cursor to the end of the line
function space2underscore()
{
  if ((REGION_ACTIVE==1)); then
    local F=$MARK T=$CURSOR
    [[ $F -gt $T ]] && F=$CURSOR T=$MARK
    BUFFER="${BUFFER[0,F]}${BUFFER[F+1,T]// /_}${BUFFER[T+1,-1]}"
  else
    local bufwords iword lastword
    bufwords=(${(z)LBUFFER})
    iword=${#bufwords}
    lastword=${bufwords[-1]}
    bufwords=(${(z)BUFFER})
    if [[ ${bufwords[iword]} =~ " " ]]; then
      BUFFER="${bufwords[0,iword-1]} ${bufwords[iword]// /_} ${bufwords[iword+1,-1]}"
    else
      RBUFFER=${RBUFFER// /_}
      zle end-of-line
    fi
  fi
}
#k# turn spaces in quoted or marked area to underscores
zle -N space2underscore && bindkey '^o_' space2underscore

## ctrl-Or to search and replace within the cmdline
## you are prompted for a string in the form: <search for>/<replace with>
## if you omit the / separator, nothing will happen
## Substitution will be done either within a selected region or
## from the cursor to the end of the line
autoload read-from-minibuffer
function replaceInArea()
{
  local SUBSTL SUBSTR REGION_ACTIVE_BAK
  REGION_ACTIVE_BAK=$REGION_ACTIVE
  local F=$MARK T=$CURSOR
  [[ $F -gt $T ]] && F=$CURSOR T=$MARK
  read-from-minibuffer "%s/"
  SUBSTR=${REPLY##(*[^\\]|)/}
  if [[ "$SUBSTR" == "$REPLY" ]]; then
    zle -M "missing /, doing nothing. Syntax: %s/<search-for>/<replace-with>"
    return 1
  fi
  SUBSTRLEN=${#SUBSTR}
  SUBSTL=${REPLY[0,-2-SUBSTRLEN]}
  #unescape escaped /
  SUBSTR=${SUBSTR//\\\//\/}
  SUBSTL=${SUBSTL//\\\//\/}
  if ((REGION_ACTIVE_BAK==1)); then
    BUFFER="${BUFFER[0,F]}${BUFFER[F+1,T]//$SUBSTL/$SUBSTR}${BUFFER[T+1,-1]}"
  else
    RBUFFER=${RBUFFER//$SUBSTL/$SUBSTR}
    zle end-of-line
  fi
}
#k# replace pattern with string insided marked or from at cursor
zle -N replaceInArea && bindkey '^or' replaceInArea

## ctrl-OR to search and replace on the whole line
## (predefined replace-string is already very similar to my replaceInArea)
autoload replace-string
autoload replace-string-again
#k# replace pattern with string in whole line
zle -N replace-string && bindkey '^oR' replace-string
zle -N replace-string-again # && bindkey ....

function logread()
{
  local -a logfile
  if pidof /usr/lib/systemd/systemd-journald &>/dev/null; then
    journalctl -e "$@"
  else
    logfile=( /var/log/(syslog|messages) )
    [[ ! -w $logfile[1] ]] && local CURDIRSUDO=$SUDO
    $CURDIRSUDO tail -n 90 "$@" $logfile[1]
  fi
}

## press ctrl-OS to prepend "screen" (just like ctrl-Os to prepend sudo)
function prependScreen()
{
  [[ -z $BUFFER ]] && zle up-history
  [[ $BUFFER != screen\* ]] && BUFFER="screen ${BUFFER}"  && CURSOR=$((CURSOR+7))
}
#k# prepend "screen"
zle -N prependScreen && bindkey '^oS' prependScreen

## press ctrl-Oi to facilitate inplace stream file editing
## i.e. select an area or put the cursor over an (escaped) filename in the cmd-line
##      if the file indeed exists, the filename will be replaced with
##      =(<filename) and >! filename will be appended to the cmdline
## e.g. you can turn a line like this
##         cat filename | grep -v abc | sed 's/def/ghi/'
##      into
##         cat =(<filename) | grep -v abc | sed 's/def/ghi/' >! filename
##      with just the press of one button
function inplaceFileRedirectEdit()
{
  local bufwords iword lastword
  bufwords=(${(z)LBUFFER})
  iword=${#bufwords}
  lastword=${bufwords[-1]}
  bufwords=(${(z)BUFFER})
  #${(Q)var}: remove one level of quote
  if [[ -e ${(Q)bufwords[iword]} ]]; then
    BUFFER="${bufwords[0,iword-1]} =(<${bufwords[iword]}) ${bufwords[iword+1,-1]} >! ${bufwords[iword]}"
  else
    zle -M "Warning: file ${bufwords[iword]} does not exist, doing nothing"
    return 1
  fi
}
#k# redirect File to itself safely
zle -N inplaceFileRedirectEdit && bindkey '^oi' inplaceFileRedirectEdit

#k# mkdir -p <dir> under cursor or marked area
bindkey '^xp' inplaceMkDirs

#k# complete word from currently visible GNU screen buffer
bindkey -r "^xs"
compdef -k _complete_screen_display complete-word '^xs'

## just type 'cd ...' to get 'cd ../..' and so on (from grml)
rationalise-dot()
{
  if [[ $LBUFFER == *.. ]] ; then
    LBUFFER+=/..
  else
    LBUFFER+=.
  fi
}
zle -N rationalise-dot && bindkey . rationalise-dot

## useful to replace the first command, e.g. ls /stuff with less /stuff
function kill_first_word_jump_beginning()
{
  [[ -z $BUFFER ]] && zle up-history
  CURSOR=0
  zle delete-word
}
#k# kill first word and jump to beginning of line
zle -N kill_first_word_jump_beginning && bindkey '^o1' kill_first_word_jump_beginning

## prevent accidental execution of rm -R / or rm -R ~
zle_confirm_rm_home_or_root()
{
  [[ -o rmstarsilent ]] && return 0
  emulate -L zsh
  setopt extendedglob
  local -a cmdline
  cmdline=(${(z)BUFFER})
  local com="${cmdline[1]}"
  [[ $cmdline[(I)(-[fiIv]#[rR][fiIv]#|--recursive)] -eq 0 ]] && return 0
  local askindex=$cmdline[(I)(\~|\~/|/|$HOME)]
  if [[ $com = "rm" && $askindex -ne 0 ]]
  then
    zle -R "zsh: sure you want to recursively delete: $cmdline[askindex] [yN]?"
    read -k
    if [[ $REPLY != [YyJj] ]]
    then
            fc -R =(<<<"$BUFFER")
            zle send-break
    fi
  fi
}
zle -N zle_confirm_rm_home_or_root
## add as widget to be executed by grmls Accept-Line if it's a valid command
zstyle ":acceptline:normal" actions "zle_confirm_rm_home_or_root"

## complete word from recent_files_cl.
_complete_recent_file() {
    compadd -a recent_files_cl
}
zle -N _complete_recent_file
#TODO: globbing (not just string) filter for completion
#test a string agains a file glob expression, without building a full globbing list first and checking if the string is contained ?
#<Valodim> for i in $a; [[ -d $i ]] && echo $i
#<xro|> mhh, so i have to rewrite (globbing modifiers) to test flags, mhhh
#<Valodim> hm
#<Valodim> for i in $a; do x=( $i(/) ); [[ -n $x ]] && echo $i; done
#<xro|> mhh, if i split a *ab*de*gh(/) into *ab*de*gh  and (/) and then do for i in ${(M)a:*ab*de*gh}; do x=( $i(/) ); [[ -n $x ]] && echo $i; done
#<xro|> that might work
#<xro|> good thing that globbing modifiers are only every allowed at the end of the pattern
#<xro|> so that will actually work :)
#<Mikachu> (that's not true, of course)
#<Mikachu> but if you only use it like that, it's fine
#<xro|> Mikachu, well it's better than before, so I'll take it, thnx :)
#ie, *ab(#q/)*de*gh would have the same effect


### Prefix Aliases ########################

alias zcp=zmv
alias zln=zmv
alias lld='ll -d'
#alias u='translate -i'
alias unix2dos='recode lat1..ibmpc'
alias dos2unix='recode ibmpc..lat1'
## ssh/scp allow sha1
alias sshsha1='ssh -o KexAlgorithms=curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha1'
alias scpsha1='scp -o KexAlgorithms=curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha1'
## ssh/scp without Host Key Checking and allowance for sha1
alias sshu='ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o KexAlgorithms=curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha1'
alias scpu="scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o KexAlgorithms=curve25519-sha256@libssh.org,diffie-hellman-group-exchange-sha256,diffie-hellman-group14-sha1"
## force ssh password authentification
alias sshp='ssh -o PubkeyAuthentication=false -o PreferredAuthentications=keyboard-interactive'
##
alias sshviaomoikane='ssh -o ProxyCommand="ssh omoikane.tittelbach.at exec nc %h %p"'
## handy on gentoo
alias smerge='emerge --update --keep-going --reinstall changed-use --ask system'
alias wmerge='emerge --update --keep-going --deep --reinstall changed-use --ask --with-bdeps y world'
alias demerge='emerge -av --depclean'
## VCS
alias gitP="git pull"
alias hgP="hg pull -u"
alias bzrP="bzr pull"
alias hgq='hg -R $(hg root)/.hg/patches/'
alias gitC="git commit"
alias hgC="hg commit"
alias git-new-workdir="sh /usr/share/doc/git/contrib/workdir/git-new-workdir"
## Watch pstree of children-, silbling- and cousin-processes
alias pstree-me="watchzsh pstree -l -p -u -U -a \$PPID"
## .DS_Store Dateien löschen
alias demac='rm -vfRi  **/.(_.|)DS_Store(.) **/._.Trashes(.) **/.Trashes(/) **/.fseventsd(/) **/.Spotlight-V<100->'
alias demood='rm -vi **/*.(#i)(mood|png|jpg|gif|txt|nfo)(.D)'
alias rmdsstore=demac
## simple-extractor
alias se=simple-extract
## useful star options
alias star="star -H exustar -acl -xattr-linux -sparse"
## list connection of a specific program
alias lssockets="lsof -n -i -a -p"
alias netstatA="netstat -a -t -p -n -u"
## Editieren und Neuladen der .zshrc.local (from http://www.plenz.com/tmp/setup/zshrc)
alias  __='${(z)EDITOR} ~/.zshrc{,.local,pre} && for f (.zshrc*~*.zwc) zcompile $f'
alias ___='source ~/.zshrc'
## Function Aliases
alias cdtemp=cdt
alias lsuuid=lsdisk
alias lslabel=lsdisk
alias refunc=freload
## Grep Aliases
alias greph="history 0 | grep"
alias GREP='grep -i --color=auto'
alias ncssl="openssl s_client -connect"
alias show-functions="typeset -f | vim -"
function list-functions { print ${(kF)functions} | sort }
# get top 10 shell commands:
alias top10='print -l ${(o)history%% *} | uniq -c | sort -nr | head -n 10'
# mplayer always on correct audio device
alias mplay='mplayer -vo vdpau -ac hwdts,hwac3,a52, -ao alsa:device=hw=$(for line (${(f)"$(aplay -l)"}) [[ $line == card\ (#b)(<0-9>):\ CK804* ]] && print $match[1] && break),0'
alias rescan_pci='echo 1 | $SUDO tee /sys/bus/pci/rescan'
alias rmZeroFilledFiles="rm -i **/*(.^L0e:'xxd -ps \$REPLY | grep -v -q 00':)"
alias wgetr='wget --tries=1 --timeout=3 -P ./ -N -nd -r -np -R "*.html*,.png,.gif,robots?txt" --no-check-certificate'
alias inxi='inxi -c10'
alias whatismyip="curl -s checkip.dyndns.org|sed -e 's/.*Current IP Address: //' -e 's/<.*$//'"
alias leasetimedecode="perl -ne 'if (\$_ =~ /\x33\x04(....)/) {print \"Lease time is \", unpack(\"N\",\$1)/(3600*24), \" days\n\";}' <"
check_com sublime_text && sublime_text() {command sublime_text "$@" &>/dev/null &}
alias test_file_on_btrfs_ok="perl -e 'if (<STDIN> =~ /^\x1+$/) {exit 1;}' <"
### Suffix Aliases ########################

### Global Aliases  ########################

alias -g §§§="&>/dev/null"
alias -g Â§Â§Â§='&>/dev/null'
#for anythign else, it's better to use zleiab (bound to ,.)


### Additional ,. expansions (better global aliases) ###
abk[SnL]="| sort -n | less"
abk[detach]="&>/dev/null </dev/null &!"
abk[closeStdIn]="<& -"
abk[newest]="*(.om[1])"
abk[ch]="*.(c|cpp|h|hpp|pde|ino)(.)"

#check_com zsh-mime-setup || { autoload zsh-mime-setup && zsh-mime-setup }
#~ alias -s ods=libreoffice
#~ alias -s odt=libreoffice
#~ alias -s pdf=evince
autoload zsh-mime-setup && zsh-mime-setup
alias -s log=less
alias -s txt=vim
alias -s config=vim
alias -s conf=vim
alias -s cpp=vim
alias -s c=vim
alias -s h=vim
alias -s pdf=evince
unalias -s py &>/dev/null
unalias -s sh &>/dev/null
unalias -s pl &>/dev/null

### Zsh Modules and associated Stuff #############

## zftp and helper functions
autoload -U zfinit
zfinit


### Handy Helper Functions ########################

function watchzsh
{
  local -a INTV
  zparseopts -D -E "i:=INTV" "n:=INTV"
  while sleep ${INTV[2]:-2} && clear; do
    printf "%s: Every %ss: %s\n\n"  "$(date "+%Y-%m-%d %H:%M:%S")" ${INTV[2]:-2} "${*[1,50]}"
    eval $@
  done
}
alias watch=watchzsh

## remove audio from video using mencode
function video_extract_audio
{
  if ! check_com __video_extract_audio; then
    if check_com avconv; then
      __video_extract_audio() {avconv -i "$1" -vn -acodec copy "$2" }
    elif check_com ffmpeg; then
      __video_extract_audio() {ffmpeg -i "$1" -vn -acodec copy "$2" }
    else
      print "please install either ffmpeg or avconv" >/dev/stderr
      return 1
    fi
  fi

  for f in "$@"; do
    __video_extract_audio "$f" "${f:r}.m4a"
  done
}

## remove audio from video using mencode
function video_remove_audio
{
  if ! check_com __video_remove_audio; then
    if check_com mencoder; then
      __video_remove_audio() {mencoder -ovc copy -nosound "$1" -o "$2" }
    elif check_com avconv; then
      __video_remove_audio() {avconv -i "$1" -an -c:v copy "$2" }
    elif check_com ffmpeg; then
      __video_remove_audio() {ffmpeg -i "$1" -an -vcodec  copy "$2" }
    else
      print "please install either mencoder, ffmpeg or avconv" >/dev/stderr
      return 1
    fi
  fi

  for f in "$@"; do
    __video_remove_audio "$f" "${f:r}_nosound.${f:e}"
  done
}

## merge video files into one mkv
if check_com mkvmerge; then
function mkvmerge_files
{
  local TARGET=$1
  shift
  mkvmerge --default-language de -o "$1" --append-mode file ${(j: + :)@}
}
fi

## pre-compile .py files
## e.g: python -c "import py_compile; py_compile.compile(r'$1'); py_compile.compile(r'$2')"
function pycompile
{
  local -a PYINTARG
  zparseopts -D -E  "i:=PYINTARG"
  ${PYINTARG[2]:-python} -c "import py_compile; py_compile.compile(r'${(j:'); py_compile.compile(r':)*}')"
}
alias py2compile="pycompile -i python2"
alias py3compile="pycompile -i python3"
alias pyprofile="python -m cProfile"
alias py2profile="python2 -m cProfile"
alias py3profile="python3 -m cProfile"
alias pyreindent='/usr/share/doc/python*/examples/Tools/scripts/reindent.py(*[1])'
alias pyflake8realerrors="flake8 --ignore=E201,E202,E231,E251,E501,E226,E303,E302,E228,E225,E401,E261,E262,W"
alias gogettools='go get -v -u github.com/jstemmer/gotags github.com/nsf/gocode code.google.com/p/go.tools/cmd/goimports'
alias govet='go tool vet -shadow=true -assign=true -atomic=true -bool=true -buildtags=true -composites=true -copylocks=true -nilfunc=true -printf=true -rangeloops=true -structtags=true -unreachable=true -unsafeptr=true'

## move file and link back
function mvlb
{
  local DEST="$argv[-1]"
  local -a SRC
  SRC=( "${argv[1,-2]}" )
  [[ -d "$DEST" ]] || return 1
  mv -v "$SRC[@]" "$DEST"
  for s in "$SRC[@]"; do
    ln -vs "$DEST/$s" "${s:h}"
  done
}

## Mercurial Shorthand for Add, Commit and Push
function hgACP
{
  command hg add $* && command hg commit $* && command hg push
}
function hgCP
{
  command hg commit $* && command hg push
}

## git add (-p); git commit
function gitAC
{
  local -a opts
  #-D: remove recognised options from $*
  #-E: don't stop at first unrecognized option
  zparseopts -D -E -a git_both_opts -- "v"
  zparseopts -D -E -a git_add_opts -- "p" "i" "f" "u"
  zparseopts -D -E -a git_commit_opts -- "m:" "-amend" "-author:" "F" "c:" "C:" "s" "a=commit_all"
  command git add ${git_both_opts[*]} ${git_add_opts[*]} $* && command git commit ${git_both_opts[*]} ${git_commit_opts[*]} ${commit_all?$*}
}
function gitCP
{
  zparseopts -D -E -a git_both_opts -- "v"
  zparseopts -D -E -a git_push_opts -- "-all" "-force" "f" "-mirror"
  command git commit ${git_both_opts[*]} $* && command git push ${git_both_opts[*]} ${git_push_opts[*]}
}
function gitACP
{
  zparseopts -D -E -a git_both_opts -- "v" "f"
  zparseopts -D -E -a git_push_opts -- "-all" "-mirror" "-force"
  gitAC ${git_both_opts[*]} $* && command git push ${git_both_opts[*]} ${git_push_opts[*]}
}
function gitInOut
{
  local -a opts
  zparseopts -D -E -a opts -- "-in" "-out"
  local gitbranch=$(git branch --no-color 2>| /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
  local gitremote=${1-origin}
  command git fetch ${gitremote} &>/dev/null
  if [[ -z $opts[*] || $opts[(I)--in] != "0" ]]; then
    print "Commits in ${gitremote} not yet merged into ${gitbranch}:\n"
    command git log ${gitbranch}..${gitremote}/${gitbranch}
    print ""
  fi
  if [[ -z $opts[*] || $opts[(I)--out] != "0" ]]; then
    print "Uncommited Changes:"
    git status -u no -s
    print "\nCommits in ${gitbranch} not yet pushed to ${gitremote}:\n"
    command git log ${gitremote}/${gitbranch}..${gitbranch}
    print ""
  fi
}
alias gitIn="gitInOut --in"
alias gitOut="gitInOut --out"
check_com gitk && function gitk
{
  {
    [[ -n $1 ]] && command gitk "$@" || command gitk --all
  } &>/dev/null &
}

#f# fcount: count number of files/directories that match the given globbing expression
##  (actually it just counts the number of entries in the array passed as argument)
function fcount
{
  print ${#@}
}

## geany is a wonderful editor, but it generates too many debug messages
if check_com geany ; then
  function geany
  {
    command geany "$@" &>/dev/null &
  }
fi

## Send File as Attachement with Thunderbird
function Mail
{
  #:a      convert to absolute filepaths
  #:s/#/   prepend file://
  #(j:,:)  join array elements with ,
  local ATTACHEMENTS=${(j:,:)@:a:s/#/file:\/\//}
  thunderbird -compose "attachment='${ATTACHEMENTS}'"
}

## Wait for termination of a process, given by its PID, that is not a child of this shell
## (propably this is not the best way to do it ;-> suggestions welcome !)
function waitpid
{
  local PID=$1
  local CMD="`ps -p $PID -o command=`"
  echo Waiting on ${PID}: ${CMD}
  if check_com inotifywait; then
    inotifywait -qq /proc/${PID}/fd/0
  else
    while { CCMD="`ps -p $PID -o command=`" && [[ "${CCMD}" == "${CMD}" ]] } ; do sleep 30; done
  fi
}
compdef _pids waitpid

## Get the total sum of filesizes of all given files
## useful for scripting
function sum_filesizes
{
  local sum=0
  local -a fsizes
  zstat -N -A fsizes +size "$@"
  for fs ($fsizes) ((sum+=fs))
  print $sum
}
alias fsizes=sum_filesizes

## Mean and Std-Deviation from a bunch of numbers
average() {
  local sum=0
  local sumsq=0
  local num=0
  while [[ -n $1 ]]; do
    sum=$((sum+$1))
    sumsq=$((sumsq+($1*$1)))
    num=$((num+1))
    shift
  done
  local avg=$((sum*1.0/num))
  local avgsq=$((sumsq*1.0/num))
  printf "sum:%d\nnum elements:%d\nmean:%f\nstddev:%f\n" $sum $num $avg $((sqrt( avgsq - avg**2 )))
}

## Output a file's whole contents save for one line
## the line that is to be skipped can be either given as an argument
## or individually for each file with the following syntax:    <filename>:<linenumber>
## this makes it quite useful for editing ~/.ssh/known_hosts
##
## catFileSkipLine takes the following arguments:
## -i               don't output file, but edit the file directly
## -l <linenumber>  default line to cut
function catFileSkipLine
{
  local -a ARGS SKIPLINE
  if ! zparseopts -a ARGS -D -E "i" "l:=SKIPLINE" ; then
    echo "Syntax: $0 [-l <linenumber>] file1[:<linenumber>] ..."
  fi
  local CUTFILE CUTLINE GCUTLINE="" INPLACE=false
  [[ "${ARGS[1]}" == "-i" ]] && INPLACE=true
  [[ ${#SKIPLINE} -gt 1 ]] && [[ "${SKIPLINE[2]}" == <-> ]] && GCUTLINE=${SKIPLINE[2]}
  while [[ -n "$1" ]]; do
    if [[ ! -e "$1"  && "$1" == (#b)(*?):(<->) ]]; then
      CUTLINE=$match[2]
      CUTFILE="$match[1]"
    else
      CUTFILE="$1"
      CUTLINE=$GCUTLINE
    fi

    if [[ -n "$CUTFILE" && -n "$CUTLINE" ]]; then
      if $INPLACE; then
        cat =(head -n $((CUTLINE-1)) "$CUTFILE"; tail -n +$((CUTLINE+1)) "$CUTFILE") >! "$CUTFILE"
      else
        (head -n $((CUTLINE-1)) "$CUTFILE"; tail -n +$((CUTLINE+1)) "$CUTFILE")
      fi
    fi
    shift
  done
}
alias delFileLine="catFileSkipLine -i"

## zed zshell editor with help
function zedwhelp
{
  echo "Ctrl-X-W to save; Ctrl-C to abort"
  zed "$@"
}

## mv files, but pipe destination through editor
function rename-edit
{
  local newnames TMPF=$(mktemp) OPARG OP=mv
  zparseopts -D "o:=OPARG"
  [[ -n "$OPARG" ]] && OP="${OPARG[*]/-o =/}"
  trap "rm $TMPF" EXIT
  for f ("$@") [[ -e "$f" ]] && print "$f" >>!$TMPF
  if ${(z)EDITOR} $TMPF; then
    newnames=(${(f)"$(<$TMPF)"})
    if [[ $# -eq ${#newnames} ]]; then
      for ((c=1;c<=$#;c++)); do
        [[ "${@[c]}" != "$newnames[c]" ]] && $OP -i -v "${@[c]}" "$newnames[c]"
      done
    else
      echo -e "ERROR: you added or deleted a line. Mapping ambiguous" >&2
      return 1
    fi
  fi
}
if ! check_com imv; then
  alias imv=rename-edit
  alias qmv="EDITOR=zedwhelp rename-edit"
  alias icp="rename-edit -o=cp"
  alias qcp="EDITOR=zedwhelp rename-edit -o=cp"
fi

## rename a file after its parent's directory name
function rename-after-parent-dir
{
  local PDIRNAME="${1:a:h:t}"
  local FILEEXT="${1:e}"
  mv -iv "$1" "${PDIRNAME}.${FILEEXT}"
}

## immediately execute a pending at-job and remove it
if check_com at ; then
  function atnow
  {
    local TMPF=$(mktemp)
    trap "rm $TMPF" EXIT
    while [[ -n "$1" ]]; do
      if at -c "$1" >!$TMPF; then
        chmod +x $TMPF
        $TMPF
        atrm $1
        atq | egrep -q "^$1 " || echo "Job $1 executed and deleted"
      #else
      #  echo -e "ERROR: $1 is not a valid AT Job ID" >&2
      fi
      shift
    done
  }
fi

## takes string on stdin and removes leading <protocol>:// string as well
## as converts all those %20, etc char escapes
if check_com perl; then
  function uri2path() { perl -n -w -e '$_=~s/^\w+:\/\///; $_=~s/(?<!%)%([0-9A-Fa-f]{2})(?{$subs=chr(hex($^N))})/$subs/g; print $_;' }
fi

## watch files for changes (close_write) and execute a command on them
## e.g.:  WAE pdflatex presentation.tex
if check_com inotifywait; then
  function inotifywaitExec()
  {
    [[ -n "$1" ]] || return 1
    local CMD=$1
    shift
    while (inotifywait -qq -e close_write $*); do
      ${=CMD} $*
    done
  }
  alias WAE=inotifywaitExec
  alias gitWAC='inotifywaitExec "git commit -m Autocommit"'
  alias hgWAC='inotifywaitExec "hg commit -m Autocommit"'
  alias bzrWAC='inotifywaitExec "bzr commit -m Autocommit"'
  alias autoPdfLatex='WAE "pdflatex -interaction=nonstopmode"'
fi

## Some quick Perl-hacks aka /useful/ oneliner (from grml)
#bew() { perl -le 'print unpack "B*","'$1'"' }
#web() { perl -le 'print pack "B*","'$1'"' }
#hew() { perl -le 'print unpack "H*","'$1'"' }
#weh() { perl -le 'print pack "H*","'$1'"' }
#pversion()    { perl -M$1 -le "print $1->VERSION" } # i. e."pversion LWP -> 5.79"
#getlinks ()   { perl -ne 'while ( m/"((www|ftp|http):\/\/.*?)"/gc ) { print $1, "\n"; }' $* }
#gethrefs ()   { perl -ne 'while ( m/href="([^"]*)"/gc ) { print $1, "\n"; }' $* }
#getanames ()  { perl -ne 'while ( m/a name="([^"]*)"/gc ) { print $1, "\n"; }' $* }
#getforms ()   { perl -ne 'while ( m:(\</?(input|form|select|option).*?\>):gic ) { print $1, "\n"; }' $* }
#getstrings () { perl -ne 'while ( m/"(.*?)"/gc ) { print $1, "\n"; }' $*}
#getanchors () { perl -ne 'while ( m/«([^«»\n]+)»/gc ) { print $1, "\n"; }' $* }
#showINC ()    { perl -e 'for (@INC) { printf "%d %s\n", $i++, $_ }' }
#vimpm ()      { vim `perldoc -l $1 | sed -e 's/pod$/pm/'` }
#vimhelp ()    { vim -c "help $1" -c on -c "au! VimEnter *" }

# from: http://wiki.gentoo.org/wiki/Project:Quality_Assurance/Backtraces
gdb_get_backtrace() {
    local exe=$1
    local core=$2

    gdb ${exe} \
        --core ${core} \
        --batch \
        --quiet \
        -ex "thread apply all bt full" \
        -ex "quit"
}

# get_ic() - queries imap servers for capabilities; real simple. no imaps
ic_get() {
    emulate -L zsh
    local port
    if [[ ! -z $1 ]] ; then
        port=${2:-143}
        print "querying imap server on $1:${port}...\n";
        print "a1 capability\na2 logout\n" | nc $1 ${port}
    else
        print "usage:\n  $0 <imap-server> [port]"
    fi
}

#f5# Show some status info
status() {
    print
    print "Date..: "$(date "+%Y-%m-%d %H:%M:%S")
    print "Shell.: Zsh $ZSH_VERSION (PID = $$, $SHLVL nests)"
    print "Term..: $TTY ($TERM), ${BAUD:+$BAUD bauds, }$COLUMNS x $LINES chars"
    print "Login.: $LOGNAME (UID = $EUID) on $HOST"
    print "System: $(cat /etc/[A-Za-z]*[_-][rv]e[lr]*)"
    print "Uptime:$(uptime)"
    print
}

## renice/ionice a process (from http://www.plenz.com/tmp/setup/zshrc)
function degrade {
  if [[ -z $1 ]]; then
    print "usage: $0 <pid>, where <pid> can also be a shell job like %1"
    return 1
  else
    local pid=$1
  fi
  # if internal job id, resolve to global pid
  [[ $pid[1] == '%' ]] && pid=${${(s.:.)jobstates[$pid[2]]}[3]%%\=*}
  if [[ $USER != $(ps --no-headers o ruser= $pid) ]]; then
    print "The process $pid does not run with your (=$USER) user privileges."
    print "I therefore will prepend sudo calls to the (io/re)nice commands."
    sudo==sudo
  else
    sudo=''
  fi
  command $sudo ionice -c3 -p $pid
  command $sudo renice 19 -p $pid
}
compdef _pids degrade

## la latest anime episode
function latestat
{
  la ~core3/lan/anime/**/*"${*}"*(.oc[1]) ~core4/TV\ Series/**/*"${*}"*(.oc[1]) ~/mnt/storage/down/**/*"${*}"*(.oc[1])
}

## pretty df (from http://www.plenz.com/tmp/setup/zshrc)
function df
{
  if [[ -z "$*" && $(command df --version 2>/dev/null) = *"GNU coreutils"* ]]
  then
    command df -TPh
  else
    command df $*
  fi
}

## improved grmls asc: autossh screen
# especially for roadwarriors using GNU screen and ssh:
if check_com autossh &>/dev/null; then
  function asc
  {
    autossh -M 0 -q -t -o "ServerAliveInterval 10" -o "ServerAliveCountMax 3" "$@" 'screen -RdU -S asc'
  }
  compdef asc=ssh
fi

## look for something in wikipedia via dns
function digwiki
{
  dig +short txt "${^@}.wp.dg.cx"
}

## run command or function in a list of directories
function rundirs
{
  local d CMD STARTDIR=$PWD
  CMD=$1; shift
  ( for d ($@) {cd -q $d && { print cd $d; ${(z)CMD} ; cd -q $STARTDIR }} )
}

## trusty iptables-show functions as part of .zshrc so they are always there
if check_com iptables && check_com gawk ; then
  function iptables-show
  {
    $SUDO zsh -c 'echo "NAT:"; iptables -t nat -L -v -n; echo -e "\n\nVANILLA:"; iptables -L -v -n; echo -e "\n\nMANGLE:"; iptables -t mangle -L -v -n' | \
       gawk '/^ pkts/ {printf "    "} /^[[:space:]]*[[:digit:]]+/ {N++; printf "%3d:", N;} /^[[:space:]]*[[:alpha:]]+/ {N=0} {print $0} ' | \
       less
  }
fi
if check_com ip6tables && check_com gawk ; then
  function ip6tables-show
  {
    $SUDO zsh -c 'echo -e "VANILLA:"; ip6tables -L -v -n; echo -e "\n\nMANGLE:"; ip6tables -t mangle -L -v -n' | \
       gawk '/^ pkts/ {printf "    "} /^[[:space:]]*[[:digit:]]+/ {N++; printf "%3d:", N;} /^[[:space:]]*[[:alpha:]]+/ {N=0} {print $0} ' | \
       less
  }
fi

#f5# Indent source code
smart-indent() {
    indent -npro -kr -i4 -ts4 -sob -l80 -ss -ncs "$@"
}

#f5# Disassemble source files using gcc and as
disassemble(){
    emulate -L zsh
    gcc -pipe -S -o - -O -g $* | as -aldh -o /dev/null
}

# usage example: 'lcheck strcpy'
#f5# Find out which libs define a symbol
lcheck() {
    if [[ -n "$1" ]] ; then
        nm -go /usr/lib/lib*.a 2>/dev/null | grep ":[[:xdigit:]]\{8\} . .*$1"
    else
        echo "Usage: lcheck <function>" >&2
    fi
}

## search for symbol in static libs (from http://www.plenz.com/tmp/setup/zshrc)
function findsym
{
  [[ -z $1 ]] && return 1

  SYMBOL=$1
  LIBDIR=${2:-/usr/lib}

  for lib ($LIBDIR/*.a) nm $lib &>/dev/null | grep -q $SYMBOL && \
      print "symbol found in $lib\n -L$LIBDIR -l${${lib:t:r}#lib}"
}

#f5# Memory overview
memusage() {
    ps aux | awk '{if (NR > 1) print $5; if (NR > 2) print "+"} END { print "p" }' | dc
}

#f5# (Mis)use \kbd{vim} as \kbd{less}
viless() {
    emulate -L zsh
    vim --cmd 'let no_plugin_maps = 1' -c "so \$VIMRUNTIME/macros/less.vim" "${@:--}"
}

# debian upgrade
#f3# Execute \kbd{apt-get update \&\& }\\&\quad \kbd{apt-get dist-upgrade}
upgrade() {
    emulate -L zsh
    if [[ -z $1 ]] ; then
        $SUDO apt-get update
        $SUDO apt-get -u upgrade
    else
        ssh $1 $SUDO apt-get update
        # ask before the upgrade
        local dummy
        ssh $1 $SUDO apt-get --no-act upgrade
        echo -n 'Process the upgrade?'
        read -q dummy
        if [[ $dummy == "y" ]] ; then
            ssh $1 $SUDO apt-get -u upgrade --yes
        fi
    fi
}

# print hex value of a number
hex() {
    emulate -L zsh
    [[ -n "$1" ]] && printf "%x\n" $1 || { print 'Usage: hex <number-to-convert>' ; return 1 }
}

# just press 'asdf' keys to toggle between dvorak and us keyboard layout
aoeu() {
    echo -n 'Switching to us keyboard layout: '
    [[ -z "$DISPLAY" ]] && $SUDO loadkeys us &>/dev/null || setxkbmap us &>/dev/null
    echo 'Done'
}
asdf() {
    echo -n 'Switching to dvorak keyboard layout: '
    [[ -z "$DISPLAY" ]] && $SUDO loadkeys dvorak &>/dev/null || setxkbmap dvorak &>/dev/null
    echo 'Done'
}
# just press 'asdf' key to toggle from neon layout to us keyboard layout
uiae() {
    echo -n 'Switching to us keyboard layout: '
    setxkbmap us && echo 'Done' || echo 'Failed'
}

## helper functions for e:'': wildcard
containscs() { command grep -q -e "$*" $REPLY }
contains() { command grep -q -i -e "$*" $REPLY }
sameas() { diff -q "$*" $REPLY &>/dev/null }
ot () { [[ $REPLY -ot ${~1} ]] }


## copy files interactively and safely (i.e. if file exists, ask if overwrite, show diff, use meld, etc)
function safecp
{
  local CMD=cp
  if [[ $1 == "--mv" ]]; then
    CMD=mv
    shift
  fi
  local DST="${@[-1]}"
  local numargs=${#@}
  for f in "${@[1,numargs-1]}"; do
    unset DSTFILE ANSW DSTDIR
    local DSTFILE ANSW DSTDIR
    [[ -d ${DST} ]] && { DSTDIR="$DST"; DSTFILE="${DST}/${f:t}" } || { DSTFILE="$DST"; DSTIR="${DST:h}" }
    if diff -q "${DSTFILE}" "$f" &>/dev/null; then
      print ${DSTFILE}(:a) "identical to source. Skipping it ..."
      continue
    fi
    [[ ! -w ${DSTDIR} || ! -x ${DSTDIR} ]] && USESUDO="$SUDO"
    while [[ -e "$DSTFILE" ]]; do
      print ${DSTFILE}(:a) "exists !\nContinue [c|p], skip [s|n], diff [d], start meld [m], start vimdiff [v] or abort [a] ?"
      read -s -k 1 ANSW
      case $ANSW in
        (p|P|c|C)
          break 1
        ;;
         (d|D)
            $( [[ ! -r "$DSTFILE" ]] && echo -n $SUDO ) diff -U 3 "${DSTFILE}" "$f" | ${PAGER-less}
         ;;
         (m|M)
            print "Doing nothing, starting meld, please merge at your own convenience"
            $( [[ ! -r "$DSTFILE" || ! -w "$DSTFILE" ]] && echo -n $SUDO ) meld "${DSTFILE}" "$f" && continue 2
         ;;
         (v|V)
            print "Doing nothing, starting vimdiff, please merge at your own convenience"
            $( [[ ! -r "$DSTFILE" || ! -w "$DSTFILE" ]] && echo -n $SUDO ) vimdiff "${DSTFILE}" "$f" && continue 2
         ;;
         (n|N|s|S)
            print "Skipping ${f:t}"
            continue 2
         ;;
         (a|A)
            print "Aborting"
            return 128
         (*)
            continue
         ;;
      esac
    done
    $( [[ ! -w ${DSTDIR} || ! -x ${DSTDIR} ]] && echo -n $SUDO ) ${(z)CMD} -vf "$f" "$DSTFILE"
  done
}
alias safemv="safecp --mv"

## Download meiner neuesten .zshrc .zshrc.local von meinem Server
function ConvenientlyUpdateMyZshrc
{
  local MVCMD="safecp --mv"
  local CPCMD="safecp"
  [[ "$1" == (--bug-me-not|-q) ]] && { [[ $(uname) == "Darwin" ]] && { MVCMD=mv; CPCMD=cp } || { MVCMD="mv -u"; CPCMD="cp -u" } }
  local t
  [[ $(uname) == "Darwin" ]] && t=$(mktemp -d -t zsh) || t=$(mktemp -d)
  trap "rm -rf $t" EXIT
  umask 077
  wget -q --tries=1 --timeout=3 -P $t -N -nd -r -np -R '*.html*,.png,.gif' --no-check-certificate https://www.tittelbach.at/zsh/
  rm -f $t/robots.txt
  if [[ -e  ~/.zshrc && -e /etc/zsh/zshrc ]] && diff -q ~/.zshrc /etc/zsh/zshrc; then
    echo -n "/etc/zsh/zshrc and ~/.zshrc identical, update /etc/zsh/zshrc too ? "
    read -q ANSW
    echo
    [[ "$ANSW" == y ]] && $=CPCMD $t/.zshrc /etc/zsh/zshrc
  fi
  $=MVCMD $t/.zshrc(|.local|.pre)(.DN) ~/ || return 0
  mkdir -p "${ZSH_USER_FUNCTIONS_DIR:-$HOME/.zsh/functions}" && $=MVCMD $t/*(.N) "${ZSH_USER_FUNCTIONS_DIR:-$HOME/.zsh/functions}" || return 0
  print "user zsh configfiles updated successfully"
}
alias UpdateMyZshrc="ConvenientlyUpdateMyZshrc; . ~/.zshrc(|.local)([1])"
alias ReallyUpdateMyZshrc="ConvenientlyUpdateMyZshrc --bug-me-not; . ~/.zshrc(|.local)([1])"

### Additional Keybindings and keyboard related stuff ########################

## ctrl-s will no longer freeze the terminal.
stty erase "^?"

#k# history-incremental-pattern-search-backward
bindkey "^r"  history-incremental-pattern-search-backward
#k# history-incremental-pattern-search-forward
bindkey "^s" history-incremental-pattern-search-forward

## use PageUp/PageDown to browse the history using a starts-with-string match from the CL
## behave just like inputrc modified readline and bash:
#bindkey "\e[5~" history-beginning-search-backward
#bindkey "\e[6~" history-beginning-search-forward

## now set up/down arrows back to up/down in history
bindkey "^[[A" up-line-or-history
bindkey "^[[B" down-line-or-history

#k# search history with menu using string on the CL
autoload history-beginning-search-menu
zle -N history-beginning-search-menu && bindkey "^f"  history-beginning-search-menu

## in menuselect scroll with PageUp/PageDown
bindkey -M menuselect "^[[1~" beginning-of-history
bindkey -M menuselect "^[[4~" end-of-history
bindkey -M menuselect "^[[5~" backward-word
bindkey -M menuselect "^[[6~" forward-word

## allow the use of the Delete/Insert keys
bindkey -M menuselect "\e[3~" delete-char-or-list
bindkey "\e[2~" quoted-insert

bindkey "^u"  backward-kill-line
bindkey "^k"  kill-line
bindkey "^c"  kill-whole-line

## alt-backspace is already the default for backwards-delete-word
## let's also set alt-delete for deleting current word (right of cursor)
#k# Kill right-side word
bindkey "3~" delete-word
bindkey "^[" delete-word

## pos1 / end keys
bindkey "^[[1~" beginning-of-line
bindkey "^[[4~" end-of-line

## exchange keybindings <Alt>, and <Alt>/ since the former is more handy
bindkey "^[," _history-complete-older
bindkey "^[/" _history-complete-newer


### Help Functions ########################

#k# display globbing reference (next page on next keypress)
GLOB_HELP_PAGE=0
zle -N help-glob && bindkey '^xg' help-glob

[[ -e ~/intel/bin/compilervars.sh ]] && source ~/intel/bin/compilervars.sh intel64
